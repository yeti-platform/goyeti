/*
FastAPI

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package goyeti

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// DfiqAPIService DfiqAPI service
type DfiqAPIService service

type ApiConfigApiV2DfiqConfigGetRequest struct {
	ctx        context.Context
	ApiService *DfiqAPIService
}

func (r ApiConfigApiV2DfiqConfigGetRequest) Execute() (*DFIQConfigResponse, *http.Response, error) {
	return r.ApiService.ConfigApiV2DfiqConfigGetExecute(r)
}

/*
ConfigApiV2DfiqConfigGet Config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConfigApiV2DfiqConfigGetRequest
*/
func (a *DfiqAPIService) ConfigApiV2DfiqConfigGet(ctx context.Context) ApiConfigApiV2DfiqConfigGetRequest {
	return ApiConfigApiV2DfiqConfigGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DFIQConfigResponse
func (a *DfiqAPIService) ConfigApiV2DfiqConfigGetExecute(r ApiConfigApiV2DfiqConfigGetRequest) (*DFIQConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DFIQConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.ConfigApiV2DfiqConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApiV2DfiqDfiqIdDeleteRequest struct {
	ctx        context.Context
	ApiService *DfiqAPIService
	dfiqId     string
}

func (r ApiDeleteApiV2DfiqDfiqIdDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteApiV2DfiqDfiqIdDeleteExecute(r)
}

/*
DeleteApiV2DfiqDfiqIdDelete Delete

Deletes a DFIQ object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dfiqId
	@return ApiDeleteApiV2DfiqDfiqIdDeleteRequest
*/
func (a *DfiqAPIService) DeleteApiV2DfiqDfiqIdDelete(ctx context.Context, dfiqId string) ApiDeleteApiV2DfiqDfiqIdDeleteRequest {
	return ApiDeleteApiV2DfiqDfiqIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		dfiqId:     dfiqId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *DfiqAPIService) DeleteApiV2DfiqDfiqIdDeleteExecute(r ApiDeleteApiV2DfiqDfiqIdDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.DeleteApiV2DfiqDfiqIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/{dfiq_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfiq_id"+"}", url.PathEscape(parameterValueToString(r.dfiqId, "dfiqId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetailsApiV2DfiqDfiqIdGetRequest struct {
	ctx        context.Context
	ApiService *DfiqAPIService
	dfiqId     interface{}
}

func (r ApiDetailsApiV2DfiqDfiqIdGetRequest) Execute() (*ResponseDetailsApiV2DfiqDfiqIdGet, *http.Response, error) {
	return r.ApiService.DetailsApiV2DfiqDfiqIdGetExecute(r)
}

/*
DetailsApiV2DfiqDfiqIdGet Details

Returns details about a DFIQ object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dfiqId
	@return ApiDetailsApiV2DfiqDfiqIdGetRequest
*/
func (a *DfiqAPIService) DetailsApiV2DfiqDfiqIdGet(ctx context.Context, dfiqId interface{}) ApiDetailsApiV2DfiqDfiqIdGetRequest {
	return ApiDetailsApiV2DfiqDfiqIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		dfiqId:     dfiqId,
	}
}

// Execute executes the request
//
//	@return ResponseDetailsApiV2DfiqDfiqIdGet
func (a *DfiqAPIService) DetailsApiV2DfiqDfiqIdGetExecute(r ApiDetailsApiV2DfiqDfiqIdGetRequest) (*ResponseDetailsApiV2DfiqDfiqIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseDetailsApiV2DfiqDfiqIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.DetailsApiV2DfiqDfiqIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/{dfiq_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfiq_id"+"}", url.PathEscape(parameterValueToString(r.dfiqId, "dfiqId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFromArchiveApiV2DfiqFromArchivePostRequest struct {
	ctx        context.Context
	ApiService *DfiqAPIService
	archive    *os.File
}

func (r ApiFromArchiveApiV2DfiqFromArchivePostRequest) Archive(archive *os.File) ApiFromArchiveApiV2DfiqFromArchivePostRequest {
	r.archive = archive
	return r
}

func (r ApiFromArchiveApiV2DfiqFromArchivePostRequest) Execute() (map[string]int32, *http.Response, error) {
	return r.ApiService.FromArchiveApiV2DfiqFromArchivePostExecute(r)
}

/*
FromArchiveApiV2DfiqFromArchivePost From Archive

Uncompresses a ZIP archive and processes the DFIQ content inside it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFromArchiveApiV2DfiqFromArchivePostRequest
*/
func (a *DfiqAPIService) FromArchiveApiV2DfiqFromArchivePost(ctx context.Context) ApiFromArchiveApiV2DfiqFromArchivePostRequest {
	return ApiFromArchiveApiV2DfiqFromArchivePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]int32
func (a *DfiqAPIService) FromArchiveApiV2DfiqFromArchivePostExecute(r ApiFromArchiveApiV2DfiqFromArchivePostRequest) (map[string]int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.FromArchiveApiV2DfiqFromArchivePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/from_archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archive == nil {
		return localVarReturnValue, nil, reportError("archive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var archiveLocalVarFormFileName string
	var archiveLocalVarFileName string
	var archiveLocalVarFileBytes []byte

	archiveLocalVarFormFileName = "archive"
	archiveLocalVarFile := r.archive

	if archiveLocalVarFile != nil {
		fbs, _ := io.ReadAll(archiveLocalVarFile)

		archiveLocalVarFileBytes = fbs
		archiveLocalVarFileName = archiveLocalVarFile.Name()
		archiveLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: archiveLocalVarFileBytes, fileName: archiveLocalVarFileName, formFileName: archiveLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNewFromYamlApiV2DfiqFromYamlPostRequest struct {
	ctx            context.Context
	ApiService     *DfiqAPIService
	newDFIQRequest *NewDFIQRequest
}

func (r ApiNewFromYamlApiV2DfiqFromYamlPostRequest) NewDFIQRequest(newDFIQRequest NewDFIQRequest) ApiNewFromYamlApiV2DfiqFromYamlPostRequest {
	r.newDFIQRequest = &newDFIQRequest
	return r
}

func (r ApiNewFromYamlApiV2DfiqFromYamlPostRequest) Execute() (*ResponseNewFromYamlApiV2DfiqFromYamlPost, *http.Response, error) {
	return r.ApiService.NewFromYamlApiV2DfiqFromYamlPostExecute(r)
}

/*
NewFromYamlApiV2DfiqFromYamlPost New From Yaml

Creates a new DFIQ object in the database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiNewFromYamlApiV2DfiqFromYamlPostRequest
*/
func (a *DfiqAPIService) NewFromYamlApiV2DfiqFromYamlPost(ctx context.Context) ApiNewFromYamlApiV2DfiqFromYamlPostRequest {
	return ApiNewFromYamlApiV2DfiqFromYamlPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResponseNewFromYamlApiV2DfiqFromYamlPost
func (a *DfiqAPIService) NewFromYamlApiV2DfiqFromYamlPostExecute(r ApiNewFromYamlApiV2DfiqFromYamlPostRequest) (*ResponseNewFromYamlApiV2DfiqFromYamlPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseNewFromYamlApiV2DfiqFromYamlPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.NewFromYamlApiV2DfiqFromYamlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/from_yaml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newDFIQRequest == nil {
		return localVarReturnValue, nil, reportError("newDFIQRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newDFIQRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiV2DfiqDfiqIdPatchRequest struct {
	ctx              context.Context
	ApiService       *DfiqAPIService
	dfiqId           interface{}
	patchDFIQRequest *PatchDFIQRequest
}

func (r ApiPatchApiV2DfiqDfiqIdPatchRequest) PatchDFIQRequest(patchDFIQRequest PatchDFIQRequest) ApiPatchApiV2DfiqDfiqIdPatchRequest {
	r.patchDFIQRequest = &patchDFIQRequest
	return r
}

func (r ApiPatchApiV2DfiqDfiqIdPatchRequest) Execute() (*ResponsePatchApiV2DfiqDfiqIdPatch, *http.Response, error) {
	return r.ApiService.PatchApiV2DfiqDfiqIdPatchExecute(r)
}

/*
PatchApiV2DfiqDfiqIdPatch Patch

Modifies an DFIQ object in the database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dfiqId
	@return ApiPatchApiV2DfiqDfiqIdPatchRequest
*/
func (a *DfiqAPIService) PatchApiV2DfiqDfiqIdPatch(ctx context.Context, dfiqId interface{}) ApiPatchApiV2DfiqDfiqIdPatchRequest {
	return ApiPatchApiV2DfiqDfiqIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		dfiqId:     dfiqId,
	}
}

// Execute executes the request
//
//	@return ResponsePatchApiV2DfiqDfiqIdPatch
func (a *DfiqAPIService) PatchApiV2DfiqDfiqIdPatchExecute(r ApiPatchApiV2DfiqDfiqIdPatchRequest) (*ResponsePatchApiV2DfiqDfiqIdPatch, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponsePatchApiV2DfiqDfiqIdPatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.PatchApiV2DfiqDfiqIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/{dfiq_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfiq_id"+"}", url.PathEscape(parameterValueToString(r.dfiqId, "dfiqId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchDFIQRequest == nil {
		return localVarReturnValue, nil, reportError("patchDFIQRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchDFIQRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApiV2DfiqSearchPostRequest struct {
	ctx               context.Context
	ApiService        *DfiqAPIService
	dFIQSearchRequest *DFIQSearchRequest
}

func (r ApiSearchApiV2DfiqSearchPostRequest) DFIQSearchRequest(dFIQSearchRequest DFIQSearchRequest) ApiSearchApiV2DfiqSearchPostRequest {
	r.dFIQSearchRequest = &dFIQSearchRequest
	return r
}

func (r ApiSearchApiV2DfiqSearchPostRequest) Execute() (*DFIQSearchResponse, *http.Response, error) {
	return r.ApiService.SearchApiV2DfiqSearchPostExecute(r)
}

/*
SearchApiV2DfiqSearchPost Search

Searches for DFIQ objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchApiV2DfiqSearchPostRequest
*/
func (a *DfiqAPIService) SearchApiV2DfiqSearchPost(ctx context.Context) ApiSearchApiV2DfiqSearchPostRequest {
	return ApiSearchApiV2DfiqSearchPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DFIQSearchResponse
func (a *DfiqAPIService) SearchApiV2DfiqSearchPostExecute(r ApiSearchApiV2DfiqSearchPostRequest) (*DFIQSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DFIQSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.SearchApiV2DfiqSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dFIQSearchRequest == nil {
		return localVarReturnValue, nil, reportError("dFIQSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dFIQSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiToArchiveApiV2DfiqToArchivePostRequest struct {
	ctx               context.Context
	ApiService        *DfiqAPIService
	dFIQSearchRequest *DFIQSearchRequest
}

func (r ApiToArchiveApiV2DfiqToArchivePostRequest) DFIQSearchRequest(dFIQSearchRequest DFIQSearchRequest) ApiToArchiveApiV2DfiqToArchivePostRequest {
	r.dFIQSearchRequest = &dFIQSearchRequest
	return r
}

func (r ApiToArchiveApiV2DfiqToArchivePostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ToArchiveApiV2DfiqToArchivePostExecute(r)
}

/*
ToArchiveApiV2DfiqToArchivePost To Archive

Compresses DFIQ objects into a ZIP archive.

The structure of the archive is as follows:
- {public, internal}/

  - type/

  - dfiq_id.yaml

    @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
    @return ApiToArchiveApiV2DfiqToArchivePostRequest
*/
func (a *DfiqAPIService) ToArchiveApiV2DfiqToArchivePost(ctx context.Context) ApiToArchiveApiV2DfiqToArchivePostRequest {
	return ApiToArchiveApiV2DfiqToArchivePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *DfiqAPIService) ToArchiveApiV2DfiqToArchivePostExecute(r ApiToArchiveApiV2DfiqToArchivePostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.ToArchiveApiV2DfiqToArchivePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/to_archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dFIQSearchRequest == nil {
		return localVarReturnValue, nil, reportError("dFIQSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dFIQSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateDfiqYamlApiV2DfiqValidatePostRequest struct {
	ctx                 context.Context
	ApiService          *DfiqAPIService
	dFIQValidateRequest *DFIQValidateRequest
}

func (r ApiValidateDfiqYamlApiV2DfiqValidatePostRequest) DFIQValidateRequest(dFIQValidateRequest DFIQValidateRequest) ApiValidateDfiqYamlApiV2DfiqValidatePostRequest {
	r.dFIQValidateRequest = &dFIQValidateRequest
	return r
}

func (r ApiValidateDfiqYamlApiV2DfiqValidatePostRequest) Execute() (*DFIQValidateResponse, *http.Response, error) {
	return r.ApiService.ValidateDfiqYamlApiV2DfiqValidatePostExecute(r)
}

/*
ValidateDfiqYamlApiV2DfiqValidatePost Validate Dfiq Yaml

Validates a DFIQ YAML string.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidateDfiqYamlApiV2DfiqValidatePostRequest
*/
func (a *DfiqAPIService) ValidateDfiqYamlApiV2DfiqValidatePost(ctx context.Context) ApiValidateDfiqYamlApiV2DfiqValidatePostRequest {
	return ApiValidateDfiqYamlApiV2DfiqValidatePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DFIQValidateResponse
func (a *DfiqAPIService) ValidateDfiqYamlApiV2DfiqValidatePostExecute(r ApiValidateDfiqYamlApiV2DfiqValidatePostRequest) (*DFIQValidateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DFIQValidateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfiqAPIService.ValidateDfiqYamlApiV2DfiqValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dfiq/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dFIQValidateRequest == nil {
		return localVarReturnValue, nil, reportError("dFIQValidateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dFIQValidateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
