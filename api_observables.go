/*
FastAPI

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package goyeti

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ObservablesAPIService ObservablesAPI service
type ObservablesAPIService service

type ApiAddContextApiV2ObservablesObservableIdContextPostRequest struct {
	ctx               context.Context
	ApiService        *ObservablesAPIService
	observableId      interface{}
	addContextRequest *AddContextRequest
}

func (r ApiAddContextApiV2ObservablesObservableIdContextPostRequest) AddContextRequest(addContextRequest AddContextRequest) ApiAddContextApiV2ObservablesObservableIdContextPostRequest {
	r.addContextRequest = &addContextRequest
	return r
}

func (r ApiAddContextApiV2ObservablesObservableIdContextPostRequest) Execute() (*ResponseAddContextApiV2ObservablesObservableIdContextPost, *http.Response, error) {
	return r.ApiService.AddContextApiV2ObservablesObservableIdContextPostExecute(r)
}

/*
AddContextApiV2ObservablesObservableIdContextPost Add Context

Adds context to an observable.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param observableId
	@return ApiAddContextApiV2ObservablesObservableIdContextPostRequest
*/
func (a *ObservablesAPIService) AddContextApiV2ObservablesObservableIdContextPost(ctx context.Context, observableId interface{}) ApiAddContextApiV2ObservablesObservableIdContextPostRequest {
	return ApiAddContextApiV2ObservablesObservableIdContextPostRequest{
		ApiService:   a,
		ctx:          ctx,
		observableId: observableId,
	}
}

// Execute executes the request
//
//	@return ResponseAddContextApiV2ObservablesObservableIdContextPost
func (a *ObservablesAPIService) AddContextApiV2ObservablesObservableIdContextPostExecute(r ApiAddContextApiV2ObservablesObservableIdContextPostRequest) (*ResponseAddContextApiV2ObservablesObservableIdContextPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseAddContextApiV2ObservablesObservableIdContextPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.AddContextApiV2ObservablesObservableIdContextPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/{observable_id}/context"
	localVarPath = strings.Replace(localVarPath, "{"+"observable_id"+"}", url.PathEscape(parameterValueToString(r.observableId, "observableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addContextRequest == nil {
		return localVarReturnValue, nil, reportError("addContextRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addContextRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTextApiV2ObservablesAddTextPostRequest struct {
	ctx            context.Context
	ApiService     *ObservablesAPIService
	addTextRequest *AddTextRequest
}

func (r ApiAddTextApiV2ObservablesAddTextPostRequest) AddTextRequest(addTextRequest AddTextRequest) ApiAddTextApiV2ObservablesAddTextPostRequest {
	r.addTextRequest = &addTextRequest
	return r
}

func (r ApiAddTextApiV2ObservablesAddTextPostRequest) Execute() (*ResponseAddTextApiV2ObservablesAddTextPost, *http.Response, error) {
	return r.ApiService.AddTextApiV2ObservablesAddTextPostExecute(r)
}

/*
AddTextApiV2ObservablesAddTextPost Add Text

Adds and returns an observable for a given string, attempting to guess
its type.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddTextApiV2ObservablesAddTextPostRequest
*/
func (a *ObservablesAPIService) AddTextApiV2ObservablesAddTextPost(ctx context.Context) ApiAddTextApiV2ObservablesAddTextPostRequest {
	return ApiAddTextApiV2ObservablesAddTextPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResponseAddTextApiV2ObservablesAddTextPost
func (a *ObservablesAPIService) AddTextApiV2ObservablesAddTextPostExecute(r ApiAddTextApiV2ObservablesAddTextPostRequest) (*ResponseAddTextApiV2ObservablesAddTextPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseAddTextApiV2ObservablesAddTextPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.AddTextApiV2ObservablesAddTextPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/add_text"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addTextRequest == nil {
		return localVarReturnValue, nil, reportError("addTextRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addTextRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkAddApiV2ObservablesBulkPostRequest struct {
	ctx                         context.Context
	ApiService                  *ObservablesAPIService
	newBulkObservableAddRequest *NewBulkObservableAddRequest
}

func (r ApiBulkAddApiV2ObservablesBulkPostRequest) NewBulkObservableAddRequest(newBulkObservableAddRequest NewBulkObservableAddRequest) ApiBulkAddApiV2ObservablesBulkPostRequest {
	r.newBulkObservableAddRequest = &newBulkObservableAddRequest
	return r
}

func (r ApiBulkAddApiV2ObservablesBulkPostRequest) Execute() (*BulkObservableAddResponse, *http.Response, error) {
	return r.ApiService.BulkAddApiV2ObservablesBulkPostExecute(r)
}

/*
BulkAddApiV2ObservablesBulkPost Bulk Add

Bulk-creates new observables in the database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBulkAddApiV2ObservablesBulkPostRequest
*/
func (a *ObservablesAPIService) BulkAddApiV2ObservablesBulkPost(ctx context.Context) ApiBulkAddApiV2ObservablesBulkPostRequest {
	return ApiBulkAddApiV2ObservablesBulkPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BulkObservableAddResponse
func (a *ObservablesAPIService) BulkAddApiV2ObservablesBulkPostExecute(r ApiBulkAddApiV2ObservablesBulkPostRequest) (*BulkObservableAddResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkObservableAddResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.BulkAddApiV2ObservablesBulkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newBulkObservableAddRequest == nil {
		return localVarReturnValue, nil, reportError("newBulkObservableAddRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newBulkObservableAddRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApiV2ObservablesObservableIdDeleteRequest struct {
	ctx          context.Context
	ApiService   *ObservablesAPIService
	observableId string
}

func (r ApiDeleteApiV2ObservablesObservableIdDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteApiV2ObservablesObservableIdDeleteExecute(r)
}

/*
DeleteApiV2ObservablesObservableIdDelete Delete

Deletes an observable.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param observableId
	@return ApiDeleteApiV2ObservablesObservableIdDeleteRequest
*/
func (a *ObservablesAPIService) DeleteApiV2ObservablesObservableIdDelete(ctx context.Context, observableId string) ApiDeleteApiV2ObservablesObservableIdDeleteRequest {
	return ApiDeleteApiV2ObservablesObservableIdDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		observableId: observableId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *ObservablesAPIService) DeleteApiV2ObservablesObservableIdDeleteExecute(r ApiDeleteApiV2ObservablesObservableIdDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.DeleteApiV2ObservablesObservableIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/{observable_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"observable_id"+"}", url.PathEscape(parameterValueToString(r.observableId, "observableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest struct {
	ctx                  context.Context
	ApiService           *ObservablesAPIService
	observableId         interface{}
	deleteContextRequest *DeleteContextRequest
}

func (r ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest) DeleteContextRequest(deleteContextRequest DeleteContextRequest) ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest {
	r.deleteContextRequest = &deleteContextRequest
	return r
}

func (r ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest) Execute() (*ResponseDeleteContextApiV2ObservablesObservableIdContextDeletePost, *http.Response, error) {
	return r.ApiService.DeleteContextApiV2ObservablesObservableIdContextDeletePostExecute(r)
}

/*
DeleteContextApiV2ObservablesObservableIdContextDeletePost Delete Context

Removes context to an observable.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param observableId
	@return ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest
*/
func (a *ObservablesAPIService) DeleteContextApiV2ObservablesObservableIdContextDeletePost(ctx context.Context, observableId interface{}) ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest {
	return ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest{
		ApiService:   a,
		ctx:          ctx,
		observableId: observableId,
	}
}

// Execute executes the request
//
//	@return ResponseDeleteContextApiV2ObservablesObservableIdContextDeletePost
func (a *ObservablesAPIService) DeleteContextApiV2ObservablesObservableIdContextDeletePostExecute(r ApiDeleteContextApiV2ObservablesObservableIdContextDeletePostRequest) (*ResponseDeleteContextApiV2ObservablesObservableIdContextDeletePost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseDeleteContextApiV2ObservablesObservableIdContextDeletePost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.DeleteContextApiV2ObservablesObservableIdContextDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/{observable_id}/context/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"observable_id"+"}", url.PathEscape(parameterValueToString(r.observableId, "observableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteContextRequest == nil {
		return localVarReturnValue, nil, reportError("deleteContextRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteContextRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetailsApiV2ObservablesObservableIdGetRequest struct {
	ctx          context.Context
	ApiService   *ObservablesAPIService
	observableId interface{}
}

func (r ApiDetailsApiV2ObservablesObservableIdGetRequest) Execute() (*ResponseDetailsApiV2ObservablesObservableIdGet, *http.Response, error) {
	return r.ApiService.DetailsApiV2ObservablesObservableIdGetExecute(r)
}

/*
DetailsApiV2ObservablesObservableIdGet Details

Returns details about an observable.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param observableId
	@return ApiDetailsApiV2ObservablesObservableIdGetRequest
*/
func (a *ObservablesAPIService) DetailsApiV2ObservablesObservableIdGet(ctx context.Context, observableId interface{}) ApiDetailsApiV2ObservablesObservableIdGetRequest {
	return ApiDetailsApiV2ObservablesObservableIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		observableId: observableId,
	}
}

// Execute executes the request
//
//	@return ResponseDetailsApiV2ObservablesObservableIdGet
func (a *ObservablesAPIService) DetailsApiV2ObservablesObservableIdGetExecute(r ApiDetailsApiV2ObservablesObservableIdGetRequest) (*ResponseDetailsApiV2ObservablesObservableIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseDetailsApiV2ObservablesObservableIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.DetailsApiV2ObservablesObservableIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/{observable_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"observable_id"+"}", url.PathEscape(parameterValueToString(r.observableId, "observableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNewApiV2ObservablesPostRequest struct {
	ctx                  context.Context
	ApiService           *ObservablesAPIService
	newObservableRequest *NewObservableRequest
}

func (r ApiNewApiV2ObservablesPostRequest) NewObservableRequest(newObservableRequest NewObservableRequest) ApiNewApiV2ObservablesPostRequest {
	r.newObservableRequest = &newObservableRequest
	return r
}

func (r ApiNewApiV2ObservablesPostRequest) Execute() (*ResponseNewApiV2ObservablesPost, *http.Response, error) {
	return r.ApiService.NewApiV2ObservablesPostExecute(r)
}

/*
NewApiV2ObservablesPost New

Creates a new observable in the database.

Raises:

	   HTTPException(400) if observable already exists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiNewApiV2ObservablesPostRequest
*/
func (a *ObservablesAPIService) NewApiV2ObservablesPost(ctx context.Context) ApiNewApiV2ObservablesPostRequest {
	return ApiNewApiV2ObservablesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResponseNewApiV2ObservablesPost
func (a *ObservablesAPIService) NewApiV2ObservablesPostExecute(r ApiNewApiV2ObservablesPostRequest) (*ResponseNewApiV2ObservablesPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseNewApiV2ObservablesPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.NewApiV2ObservablesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newObservableRequest == nil {
		return localVarReturnValue, nil, reportError("newObservableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newObservableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNewExtendedApiV2ObservablesExtendedPostRequest struct {
	ctx                          context.Context
	ApiService                   *ObservablesAPIService
	newExtendedObservableRequest *NewExtendedObservableRequest
}

func (r ApiNewExtendedApiV2ObservablesExtendedPostRequest) NewExtendedObservableRequest(newExtendedObservableRequest NewExtendedObservableRequest) ApiNewExtendedApiV2ObservablesExtendedPostRequest {
	r.newExtendedObservableRequest = &newExtendedObservableRequest
	return r
}

func (r ApiNewExtendedApiV2ObservablesExtendedPostRequest) Execute() (*ResponseNewExtendedApiV2ObservablesExtendedPost, *http.Response, error) {
	return r.ApiService.NewExtendedApiV2ObservablesExtendedPostExecute(r)
}

/*
NewExtendedApiV2ObservablesExtendedPost New Extended

Creates a new observable in the database with extended properties.

Raises:

	   HTTPException(400) if observable already exists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiNewExtendedApiV2ObservablesExtendedPostRequest
*/
func (a *ObservablesAPIService) NewExtendedApiV2ObservablesExtendedPost(ctx context.Context) ApiNewExtendedApiV2ObservablesExtendedPostRequest {
	return ApiNewExtendedApiV2ObservablesExtendedPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResponseNewExtendedApiV2ObservablesExtendedPost
func (a *ObservablesAPIService) NewExtendedApiV2ObservablesExtendedPostExecute(r ApiNewExtendedApiV2ObservablesExtendedPostRequest) (*ResponseNewExtendedApiV2ObservablesExtendedPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseNewExtendedApiV2ObservablesExtendedPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.NewExtendedApiV2ObservablesExtendedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/extended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newExtendedObservableRequest == nil {
		return localVarReturnValue, nil, reportError("newExtendedObservableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newExtendedObservableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiObservablesRootApiV2ObservablesGetRequest struct {
	ctx        context.Context
	ApiService *ObservablesAPIService
}

func (r ApiObservablesRootApiV2ObservablesGetRequest) Execute() ([]Observable, *http.Response, error) {
	return r.ApiService.ObservablesRootApiV2ObservablesGetExecute(r)
}

/*
ObservablesRootApiV2ObservablesGet Observables Root

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiObservablesRootApiV2ObservablesGetRequest
*/
func (a *ObservablesAPIService) ObservablesRootApiV2ObservablesGet(ctx context.Context) ApiObservablesRootApiV2ObservablesGetRequest {
	return ApiObservablesRootApiV2ObservablesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Observable
func (a *ObservablesAPIService) ObservablesRootApiV2ObservablesGetExecute(r ApiObservablesRootApiV2ObservablesGetRequest) ([]Observable, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Observable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.ObservablesRootApiV2ObservablesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiV2ObservablesObservableIdPatchRequest struct {
	ctx                    context.Context
	ApiService             *ObservablesAPIService
	observableId           interface{}
	patchObservableRequest *PatchObservableRequest
}

func (r ApiPatchApiV2ObservablesObservableIdPatchRequest) PatchObservableRequest(patchObservableRequest PatchObservableRequest) ApiPatchApiV2ObservablesObservableIdPatchRequest {
	r.patchObservableRequest = &patchObservableRequest
	return r
}

func (r ApiPatchApiV2ObservablesObservableIdPatchRequest) Execute() (*ResponsePatchApiV2ObservablesObservableIdPatch, *http.Response, error) {
	return r.ApiService.PatchApiV2ObservablesObservableIdPatchExecute(r)
}

/*
PatchApiV2ObservablesObservableIdPatch Patch

Modifies observable in the database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param observableId
	@return ApiPatchApiV2ObservablesObservableIdPatchRequest
*/
func (a *ObservablesAPIService) PatchApiV2ObservablesObservableIdPatch(ctx context.Context, observableId interface{}) ApiPatchApiV2ObservablesObservableIdPatchRequest {
	return ApiPatchApiV2ObservablesObservableIdPatchRequest{
		ApiService:   a,
		ctx:          ctx,
		observableId: observableId,
	}
}

// Execute executes the request
//
//	@return ResponsePatchApiV2ObservablesObservableIdPatch
func (a *ObservablesAPIService) PatchApiV2ObservablesObservableIdPatchExecute(r ApiPatchApiV2ObservablesObservableIdPatchRequest) (*ResponsePatchApiV2ObservablesObservableIdPatch, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponsePatchApiV2ObservablesObservableIdPatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.PatchApiV2ObservablesObservableIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/{observable_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"observable_id"+"}", url.PathEscape(parameterValueToString(r.observableId, "observableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchObservableRequest == nil {
		return localVarReturnValue, nil, reportError("patchObservableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchObservableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApiV2ObservablesSearchPostRequest struct {
	ctx                     context.Context
	ApiService              *ObservablesAPIService
	observableSearchRequest *ObservableSearchRequest
}

func (r ApiSearchApiV2ObservablesSearchPostRequest) ObservableSearchRequest(observableSearchRequest ObservableSearchRequest) ApiSearchApiV2ObservablesSearchPostRequest {
	r.observableSearchRequest = &observableSearchRequest
	return r
}

func (r ApiSearchApiV2ObservablesSearchPostRequest) Execute() (*ObservableSearchResponse, *http.Response, error) {
	return r.ApiService.SearchApiV2ObservablesSearchPostExecute(r)
}

/*
SearchApiV2ObservablesSearchPost Search

Searches for observables.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchApiV2ObservablesSearchPostRequest
*/
func (a *ObservablesAPIService) SearchApiV2ObservablesSearchPost(ctx context.Context) ApiSearchApiV2ObservablesSearchPostRequest {
	return ApiSearchApiV2ObservablesSearchPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ObservableSearchResponse
func (a *ObservablesAPIService) SearchApiV2ObservablesSearchPostExecute(r ApiSearchApiV2ObservablesSearchPostRequest) (*ObservableSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObservableSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.SearchApiV2ObservablesSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.observableSearchRequest == nil {
		return localVarReturnValue, nil, reportError("observableSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.observableSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagObservableApiV2ObservablesTagPostRequest struct {
	ctx                  context.Context
	ApiService           *ObservablesAPIService
	observableTagRequest *ObservableTagRequest
}

func (r ApiTagObservableApiV2ObservablesTagPostRequest) ObservableTagRequest(observableTagRequest ObservableTagRequest) ApiTagObservableApiV2ObservablesTagPostRequest {
	r.observableTagRequest = &observableTagRequest
	return r
}

func (r ApiTagObservableApiV2ObservablesTagPostRequest) Execute() (*ObservableTagResponse, *http.Response, error) {
	return r.ApiService.TagObservableApiV2ObservablesTagPostExecute(r)
}

/*
TagObservableApiV2ObservablesTagPost Tag Observable

Tags a set of observables, individually or in bulk.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTagObservableApiV2ObservablesTagPostRequest
*/
func (a *ObservablesAPIService) TagObservableApiV2ObservablesTagPost(ctx context.Context) ApiTagObservableApiV2ObservablesTagPostRequest {
	return ApiTagObservableApiV2ObservablesTagPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ObservableTagResponse
func (a *ObservablesAPIService) TagObservableApiV2ObservablesTagPostExecute(r ApiTagObservableApiV2ObservablesTagPostRequest) (*ObservableTagResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObservableTagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObservablesAPIService.TagObservableApiV2ObservablesTagPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/observables/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.observableTagRequest == nil {
		return localVarReturnValue, nil, reportError("observableTagRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.observableTagRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
