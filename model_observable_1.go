/*
FastAPI

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package goyeti

import (
	"encoding/json"
	"fmt"
)

// Observable1 struct for Observable1
type Observable1 struct {
	ASNInput         *ASNInput
	BICInput         *BICInput
	CIDRInput        *CIDRInput
	CertificateInput *CertificateInput
	CommandLineInput *CommandLineInput
	DockerImageInput *DockerImageInput
	EmailInput       *EmailInput
	FileInput        *FileInput
	GenericInput     *GenericInput
	HostnameInput    *HostnameInput
	IBANInput        *IBANInput
	IPv4Input        *IPv4Input
	IPv6Input        *IPv6Input
	ImphashInput     *ImphashInput
	JA3Input         *JA3Input
	JARMInput        *JARMInput
	MD5Input         *MD5Input
	MacAddressInput  *MacAddressInput
	MutexInput       *MutexInput
	NamedPipeInput   *NamedPipeInput
	PackageInput     *PackageInput
	PathInput        *PathInput
	RegistryKeyInput *RegistryKeyInput
	SHA1Input        *SHA1Input
	SHA256Input      *SHA256Input
	SsdeepInput      *SsdeepInput
	TLSHInput        *TLSHInput
	UrlInput         *UrlInput
	UserAccountInput *UserAccountInput
	UserAgentInput   *UserAgentInput
	WalletInput      *WalletInput
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *Observable1) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into ASNInput
	err = json.Unmarshal(data, &dst.ASNInput)
	if err == nil {
		jsonASNInput, _ := json.Marshal(dst.ASNInput)
		if string(jsonASNInput) == "{}" { // empty struct
			dst.ASNInput = nil
		} else {
			return nil // data stored in dst.ASNInput, return on the first match
		}
	} else {
		dst.ASNInput = nil
	}

	// try to unmarshal JSON data into BICInput
	err = json.Unmarshal(data, &dst.BICInput)
	if err == nil {
		jsonBICInput, _ := json.Marshal(dst.BICInput)
		if string(jsonBICInput) == "{}" { // empty struct
			dst.BICInput = nil
		} else {
			return nil // data stored in dst.BICInput, return on the first match
		}
	} else {
		dst.BICInput = nil
	}

	// try to unmarshal JSON data into CIDRInput
	err = json.Unmarshal(data, &dst.CIDRInput)
	if err == nil {
		jsonCIDRInput, _ := json.Marshal(dst.CIDRInput)
		if string(jsonCIDRInput) == "{}" { // empty struct
			dst.CIDRInput = nil
		} else {
			return nil // data stored in dst.CIDRInput, return on the first match
		}
	} else {
		dst.CIDRInput = nil
	}

	// try to unmarshal JSON data into CertificateInput
	err = json.Unmarshal(data, &dst.CertificateInput)
	if err == nil {
		jsonCertificateInput, _ := json.Marshal(dst.CertificateInput)
		if string(jsonCertificateInput) == "{}" { // empty struct
			dst.CertificateInput = nil
		} else {
			return nil // data stored in dst.CertificateInput, return on the first match
		}
	} else {
		dst.CertificateInput = nil
	}

	// try to unmarshal JSON data into CommandLineInput
	err = json.Unmarshal(data, &dst.CommandLineInput)
	if err == nil {
		jsonCommandLineInput, _ := json.Marshal(dst.CommandLineInput)
		if string(jsonCommandLineInput) == "{}" { // empty struct
			dst.CommandLineInput = nil
		} else {
			return nil // data stored in dst.CommandLineInput, return on the first match
		}
	} else {
		dst.CommandLineInput = nil
	}

	// try to unmarshal JSON data into DockerImageInput
	err = json.Unmarshal(data, &dst.DockerImageInput)
	if err == nil {
		jsonDockerImageInput, _ := json.Marshal(dst.DockerImageInput)
		if string(jsonDockerImageInput) == "{}" { // empty struct
			dst.DockerImageInput = nil
		} else {
			return nil // data stored in dst.DockerImageInput, return on the first match
		}
	} else {
		dst.DockerImageInput = nil
	}

	// try to unmarshal JSON data into EmailInput
	err = json.Unmarshal(data, &dst.EmailInput)
	if err == nil {
		jsonEmailInput, _ := json.Marshal(dst.EmailInput)
		if string(jsonEmailInput) == "{}" { // empty struct
			dst.EmailInput = nil
		} else {
			return nil // data stored in dst.EmailInput, return on the first match
		}
	} else {
		dst.EmailInput = nil
	}

	// try to unmarshal JSON data into FileInput
	err = json.Unmarshal(data, &dst.FileInput)
	if err == nil {
		jsonFileInput, _ := json.Marshal(dst.FileInput)
		if string(jsonFileInput) == "{}" { // empty struct
			dst.FileInput = nil
		} else {
			return nil // data stored in dst.FileInput, return on the first match
		}
	} else {
		dst.FileInput = nil
	}

	// try to unmarshal JSON data into GenericInput
	err = json.Unmarshal(data, &dst.GenericInput)
	if err == nil {
		jsonGenericInput, _ := json.Marshal(dst.GenericInput)
		if string(jsonGenericInput) == "{}" { // empty struct
			dst.GenericInput = nil
		} else {
			return nil // data stored in dst.GenericInput, return on the first match
		}
	} else {
		dst.GenericInput = nil
	}

	// try to unmarshal JSON data into HostnameInput
	err = json.Unmarshal(data, &dst.HostnameInput)
	if err == nil {
		jsonHostnameInput, _ := json.Marshal(dst.HostnameInput)
		if string(jsonHostnameInput) == "{}" { // empty struct
			dst.HostnameInput = nil
		} else {
			return nil // data stored in dst.HostnameInput, return on the first match
		}
	} else {
		dst.HostnameInput = nil
	}

	// try to unmarshal JSON data into IBANInput
	err = json.Unmarshal(data, &dst.IBANInput)
	if err == nil {
		jsonIBANInput, _ := json.Marshal(dst.IBANInput)
		if string(jsonIBANInput) == "{}" { // empty struct
			dst.IBANInput = nil
		} else {
			return nil // data stored in dst.IBANInput, return on the first match
		}
	} else {
		dst.IBANInput = nil
	}

	// try to unmarshal JSON data into IPv4Input
	err = json.Unmarshal(data, &dst.IPv4Input)
	if err == nil {
		jsonIPv4Input, _ := json.Marshal(dst.IPv4Input)
		if string(jsonIPv4Input) == "{}" { // empty struct
			dst.IPv4Input = nil
		} else {
			return nil // data stored in dst.IPv4Input, return on the first match
		}
	} else {
		dst.IPv4Input = nil
	}

	// try to unmarshal JSON data into IPv6Input
	err = json.Unmarshal(data, &dst.IPv6Input)
	if err == nil {
		jsonIPv6Input, _ := json.Marshal(dst.IPv6Input)
		if string(jsonIPv6Input) == "{}" { // empty struct
			dst.IPv6Input = nil
		} else {
			return nil // data stored in dst.IPv6Input, return on the first match
		}
	} else {
		dst.IPv6Input = nil
	}

	// try to unmarshal JSON data into ImphashInput
	err = json.Unmarshal(data, &dst.ImphashInput)
	if err == nil {
		jsonImphashInput, _ := json.Marshal(dst.ImphashInput)
		if string(jsonImphashInput) == "{}" { // empty struct
			dst.ImphashInput = nil
		} else {
			return nil // data stored in dst.ImphashInput, return on the first match
		}
	} else {
		dst.ImphashInput = nil
	}

	// try to unmarshal JSON data into JA3Input
	err = json.Unmarshal(data, &dst.JA3Input)
	if err == nil {
		jsonJA3Input, _ := json.Marshal(dst.JA3Input)
		if string(jsonJA3Input) == "{}" { // empty struct
			dst.JA3Input = nil
		} else {
			return nil // data stored in dst.JA3Input, return on the first match
		}
	} else {
		dst.JA3Input = nil
	}

	// try to unmarshal JSON data into JARMInput
	err = json.Unmarshal(data, &dst.JARMInput)
	if err == nil {
		jsonJARMInput, _ := json.Marshal(dst.JARMInput)
		if string(jsonJARMInput) == "{}" { // empty struct
			dst.JARMInput = nil
		} else {
			return nil // data stored in dst.JARMInput, return on the first match
		}
	} else {
		dst.JARMInput = nil
	}

	// try to unmarshal JSON data into MD5Input
	err = json.Unmarshal(data, &dst.MD5Input)
	if err == nil {
		jsonMD5Input, _ := json.Marshal(dst.MD5Input)
		if string(jsonMD5Input) == "{}" { // empty struct
			dst.MD5Input = nil
		} else {
			return nil // data stored in dst.MD5Input, return on the first match
		}
	} else {
		dst.MD5Input = nil
	}

	// try to unmarshal JSON data into MacAddressInput
	err = json.Unmarshal(data, &dst.MacAddressInput)
	if err == nil {
		jsonMacAddressInput, _ := json.Marshal(dst.MacAddressInput)
		if string(jsonMacAddressInput) == "{}" { // empty struct
			dst.MacAddressInput = nil
		} else {
			return nil // data stored in dst.MacAddressInput, return on the first match
		}
	} else {
		dst.MacAddressInput = nil
	}

	// try to unmarshal JSON data into MutexInput
	err = json.Unmarshal(data, &dst.MutexInput)
	if err == nil {
		jsonMutexInput, _ := json.Marshal(dst.MutexInput)
		if string(jsonMutexInput) == "{}" { // empty struct
			dst.MutexInput = nil
		} else {
			return nil // data stored in dst.MutexInput, return on the first match
		}
	} else {
		dst.MutexInput = nil
	}

	// try to unmarshal JSON data into NamedPipeInput
	err = json.Unmarshal(data, &dst.NamedPipeInput)
	if err == nil {
		jsonNamedPipeInput, _ := json.Marshal(dst.NamedPipeInput)
		if string(jsonNamedPipeInput) == "{}" { // empty struct
			dst.NamedPipeInput = nil
		} else {
			return nil // data stored in dst.NamedPipeInput, return on the first match
		}
	} else {
		dst.NamedPipeInput = nil
	}

	// try to unmarshal JSON data into PackageInput
	err = json.Unmarshal(data, &dst.PackageInput)
	if err == nil {
		jsonPackageInput, _ := json.Marshal(dst.PackageInput)
		if string(jsonPackageInput) == "{}" { // empty struct
			dst.PackageInput = nil
		} else {
			return nil // data stored in dst.PackageInput, return on the first match
		}
	} else {
		dst.PackageInput = nil
	}

	// try to unmarshal JSON data into PathInput
	err = json.Unmarshal(data, &dst.PathInput)
	if err == nil {
		jsonPathInput, _ := json.Marshal(dst.PathInput)
		if string(jsonPathInput) == "{}" { // empty struct
			dst.PathInput = nil
		} else {
			return nil // data stored in dst.PathInput, return on the first match
		}
	} else {
		dst.PathInput = nil
	}

	// try to unmarshal JSON data into RegistryKeyInput
	err = json.Unmarshal(data, &dst.RegistryKeyInput)
	if err == nil {
		jsonRegistryKeyInput, _ := json.Marshal(dst.RegistryKeyInput)
		if string(jsonRegistryKeyInput) == "{}" { // empty struct
			dst.RegistryKeyInput = nil
		} else {
			return nil // data stored in dst.RegistryKeyInput, return on the first match
		}
	} else {
		dst.RegistryKeyInput = nil
	}

	// try to unmarshal JSON data into SHA1Input
	err = json.Unmarshal(data, &dst.SHA1Input)
	if err == nil {
		jsonSHA1Input, _ := json.Marshal(dst.SHA1Input)
		if string(jsonSHA1Input) == "{}" { // empty struct
			dst.SHA1Input = nil
		} else {
			return nil // data stored in dst.SHA1Input, return on the first match
		}
	} else {
		dst.SHA1Input = nil
	}

	// try to unmarshal JSON data into SHA256Input
	err = json.Unmarshal(data, &dst.SHA256Input)
	if err == nil {
		jsonSHA256Input, _ := json.Marshal(dst.SHA256Input)
		if string(jsonSHA256Input) == "{}" { // empty struct
			dst.SHA256Input = nil
		} else {
			return nil // data stored in dst.SHA256Input, return on the first match
		}
	} else {
		dst.SHA256Input = nil
	}

	// try to unmarshal JSON data into SsdeepInput
	err = json.Unmarshal(data, &dst.SsdeepInput)
	if err == nil {
		jsonSsdeepInput, _ := json.Marshal(dst.SsdeepInput)
		if string(jsonSsdeepInput) == "{}" { // empty struct
			dst.SsdeepInput = nil
		} else {
			return nil // data stored in dst.SsdeepInput, return on the first match
		}
	} else {
		dst.SsdeepInput = nil
	}

	// try to unmarshal JSON data into TLSHInput
	err = json.Unmarshal(data, &dst.TLSHInput)
	if err == nil {
		jsonTLSHInput, _ := json.Marshal(dst.TLSHInput)
		if string(jsonTLSHInput) == "{}" { // empty struct
			dst.TLSHInput = nil
		} else {
			return nil // data stored in dst.TLSHInput, return on the first match
		}
	} else {
		dst.TLSHInput = nil
	}

	// try to unmarshal JSON data into UrlInput
	err = json.Unmarshal(data, &dst.UrlInput)
	if err == nil {
		jsonUrlInput, _ := json.Marshal(dst.UrlInput)
		if string(jsonUrlInput) == "{}" { // empty struct
			dst.UrlInput = nil
		} else {
			return nil // data stored in dst.UrlInput, return on the first match
		}
	} else {
		dst.UrlInput = nil
	}

	// try to unmarshal JSON data into UserAccountInput
	err = json.Unmarshal(data, &dst.UserAccountInput)
	if err == nil {
		jsonUserAccountInput, _ := json.Marshal(dst.UserAccountInput)
		if string(jsonUserAccountInput) == "{}" { // empty struct
			dst.UserAccountInput = nil
		} else {
			return nil // data stored in dst.UserAccountInput, return on the first match
		}
	} else {
		dst.UserAccountInput = nil
	}

	// try to unmarshal JSON data into UserAgentInput
	err = json.Unmarshal(data, &dst.UserAgentInput)
	if err == nil {
		jsonUserAgentInput, _ := json.Marshal(dst.UserAgentInput)
		if string(jsonUserAgentInput) == "{}" { // empty struct
			dst.UserAgentInput = nil
		} else {
			return nil // data stored in dst.UserAgentInput, return on the first match
		}
	} else {
		dst.UserAgentInput = nil
	}

	// try to unmarshal JSON data into WalletInput
	err = json.Unmarshal(data, &dst.WalletInput)
	if err == nil {
		jsonWalletInput, _ := json.Marshal(dst.WalletInput)
		if string(jsonWalletInput) == "{}" { // empty struct
			dst.WalletInput = nil
		} else {
			return nil // data stored in dst.WalletInput, return on the first match
		}
	} else {
		dst.WalletInput = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(Observable1)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Observable1) MarshalJSON() ([]byte, error) {
	if src.ASNInput != nil {
		return json.Marshal(&src.ASNInput)
	}

	if src.BICInput != nil {
		return json.Marshal(&src.BICInput)
	}

	if src.CIDRInput != nil {
		return json.Marshal(&src.CIDRInput)
	}

	if src.CertificateInput != nil {
		return json.Marshal(&src.CertificateInput)
	}

	if src.CommandLineInput != nil {
		return json.Marshal(&src.CommandLineInput)
	}

	if src.DockerImageInput != nil {
		return json.Marshal(&src.DockerImageInput)
	}

	if src.EmailInput != nil {
		return json.Marshal(&src.EmailInput)
	}

	if src.FileInput != nil {
		return json.Marshal(&src.FileInput)
	}

	if src.GenericInput != nil {
		return json.Marshal(&src.GenericInput)
	}

	if src.HostnameInput != nil {
		return json.Marshal(&src.HostnameInput)
	}

	if src.IBANInput != nil {
		return json.Marshal(&src.IBANInput)
	}

	if src.IPv4Input != nil {
		return json.Marshal(&src.IPv4Input)
	}

	if src.IPv6Input != nil {
		return json.Marshal(&src.IPv6Input)
	}

	if src.ImphashInput != nil {
		return json.Marshal(&src.ImphashInput)
	}

	if src.JA3Input != nil {
		return json.Marshal(&src.JA3Input)
	}

	if src.JARMInput != nil {
		return json.Marshal(&src.JARMInput)
	}

	if src.MD5Input != nil {
		return json.Marshal(&src.MD5Input)
	}

	if src.MacAddressInput != nil {
		return json.Marshal(&src.MacAddressInput)
	}

	if src.MutexInput != nil {
		return json.Marshal(&src.MutexInput)
	}

	if src.NamedPipeInput != nil {
		return json.Marshal(&src.NamedPipeInput)
	}

	if src.PackageInput != nil {
		return json.Marshal(&src.PackageInput)
	}

	if src.PathInput != nil {
		return json.Marshal(&src.PathInput)
	}

	if src.RegistryKeyInput != nil {
		return json.Marshal(&src.RegistryKeyInput)
	}

	if src.SHA1Input != nil {
		return json.Marshal(&src.SHA1Input)
	}

	if src.SHA256Input != nil {
		return json.Marshal(&src.SHA256Input)
	}

	if src.SsdeepInput != nil {
		return json.Marshal(&src.SsdeepInput)
	}

	if src.TLSHInput != nil {
		return json.Marshal(&src.TLSHInput)
	}

	if src.UrlInput != nil {
		return json.Marshal(&src.UrlInput)
	}

	if src.UserAccountInput != nil {
		return json.Marshal(&src.UserAccountInput)
	}

	if src.UserAgentInput != nil {
		return json.Marshal(&src.UserAgentInput)
	}

	if src.WalletInput != nil {
		return json.Marshal(&src.WalletInput)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableObservable1 struct {
	value *Observable1
	isSet bool
}

func (v NullableObservable1) Get() *Observable1 {
	return v.value
}

func (v *NullableObservable1) Set(val *Observable1) {
	v.value = val
	v.isSet = true
}

func (v NullableObservable1) IsSet() bool {
	return v.isSet
}

func (v *NullableObservable1) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableObservable1(val *Observable1) *NullableObservable1 {
	return &NullableObservable1{value: val, isSet: true}
}

func (v NullableObservable1) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableObservable1) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
